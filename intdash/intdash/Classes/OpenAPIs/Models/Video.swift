//
// Video.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Video: Codable {

    /** 動画（video）のUUID */
    public var uuid: UUID
    /** 計測のUUID */
    public var measurementUuid: UUID
    public var measurement: MediaMeasurement?
    /** エッジのUUID */
    public var edgeUuid: UUID
    /** チャンネル */
    public var channel: Int
    public var codec: VideoCodecs
    public var sourceDataType: VideoSourceDataType
    /** 計測開始からのオフセット（マイクロ秒） */
    public var offsetTime: Int
    /** 長さ（マイクロ秒） */
    public var duration: Int
    /** フレームレート（fps） */
    public var fps: Double
    /** 動画の幅 */
    public var width: Int
    /** 動画の高さ */
    public var height: Int
    public var status: VideoStatus
    public var hls: Playlist?
    /** この動画を変換して作成されたMP4のリスト */
    public var mp4s: [MP4]
    /** この動画を変換して作成されたJPEGのリスト */
    public var jpegs: [Jpeg]
    /** 作成された日時 */
    public var createdAt: Date
    /** 最終更新日時 */
    public var updatedAt: Date

    public init(uuid: UUID, measurementUuid: UUID, measurement: MediaMeasurement? = nil, edgeUuid: UUID, channel: Int, codec: VideoCodecs, sourceDataType: VideoSourceDataType, offsetTime: Int, duration: Int, fps: Double, width: Int, height: Int, status: VideoStatus, hls: Playlist? = nil, mp4s: [MP4], jpegs: [Jpeg], createdAt: Date, updatedAt: Date) {
        self.uuid = uuid
        self.measurementUuid = measurementUuid
        self.measurement = measurement
        self.edgeUuid = edgeUuid
        self.channel = channel
        self.codec = codec
        self.sourceDataType = sourceDataType
        self.offsetTime = offsetTime
        self.duration = duration
        self.fps = fps
        self.width = width
        self.height = height
        self.status = status
        self.hls = hls
        self.mp4s = mp4s
        self.jpegs = jpegs
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case uuid
        case measurementUuid = "measurement_uuid"
        case measurement
        case edgeUuid = "edge_uuid"
        case channel
        case codec
        case sourceDataType = "source_data_type"
        case offsetTime = "offset_time"
        case duration
        case fps
        case width
        case height
        case status
        case hls
        case mp4s
        case jpegs
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(uuid, forKey: .uuid)
        try container.encode(measurementUuid, forKey: .measurementUuid)
        try container.encodeIfPresent(measurement, forKey: .measurement)
        try container.encode(edgeUuid, forKey: .edgeUuid)
        try container.encode(channel, forKey: .channel)
        try container.encode(codec, forKey: .codec)
        try container.encode(sourceDataType, forKey: .sourceDataType)
        try container.encode(offsetTime, forKey: .offsetTime)
        try container.encode(duration, forKey: .duration)
        try container.encode(fps, forKey: .fps)
        try container.encode(width, forKey: .width)
        try container.encode(height, forKey: .height)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(hls, forKey: .hls)
        try container.encode(mp4s, forKey: .mp4s)
        try container.encode(jpegs, forKey: .jpegs)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
}

